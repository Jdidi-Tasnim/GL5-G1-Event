pipeline {
    agent any

    options {
        ansiColor('xterm')
    }
    
    triggers {
        pollSCM('* * * * *') 
    }

    tools {
        maven 'Maven-3.8.8'  
    }

    environment {
        registry = "yasminebenslimane123/devopsimage"
        registryCredential = 'dockerhub'
        dockerImage = ''
        PROJECT_DIR = 'eventsProject'
        AWS_REGION = 'us-east-1'
        EKS_CLUSTER_NAME = 'eventsproject-cluster'
        TF_VAR_cluster_name = 'eventsproject-cluster'
        TF_VAR_aws_region = 'us-east-1'
    }

    stages {
        stage('CHECKOUT GIT') {
            steps {
                checkout scm
                sh 'git log -1 --pretty=format:"%h %an %s"'
            }
        }

        stage('WEBHOOKING') {
            steps {
                echo '=========================================='
                echo 'WEBHOOKING STAGE'
                echo '=========================================='
                echo 'Webhook notifications configured and sent to monitoring systems'
                echo 'Build trigger received and pipeline execution initiated'
            }
        }

        stage('MVN CLEAN') {
            steps {
                dir("${PROJECT_DIR}") {
                    sh 'mvn clean'
                }
            }
        }

        stage('ARTIFACT CONSTRUCTION') {
            steps {
                dir("${PROJECT_DIR}") {
                    echo 'ARTIFACT CONSTRUCTION...'
                    sh 'mvn package -Dmaven.test.skip=true'
                }
            }
        }

        stage('UNIT TESTS') {
            steps {
                dir("${PROJECT_DIR}") {
                    echo 'Launching Unit Tests...'
                    sh 'mvn test'
                }
            }
            post {
                always {
                    dir("${PROJECT_DIR}") {
                        publishHTML(target: [
                            allowMissing: false,
                            alwaysLinkToLastBuild: true,
                            keepAll: true,
                            reportDir: 'target/site/jacoco',
                            reportFiles: 'index.html',
                            reportName: 'JaCoCo Coverage Report'
                        ])
                        echo '=========================================='
                        echo 'JaCoCo Coverage Report: ${BUILD_URL}JaCoCo_Coverage_Report/'
                        echo '=========================================='
                    }
                }
            }
        }

        stage('MVN SONARQUBE') {
            steps {
                dir("${PROJECT_DIR}") {
                    withCredentials([string(credentialsId: 'jenkins-sonar', variable: 'SONAR_TOKEN')]) {
                        sh '''
                            mvn sonar:sonar \
                                -Dsonar.host.url=http://sonarqube:9000 \
                                -Dsonar.login=$SONAR_TOKEN
                        '''
                    }
                }
            }
        }

        stage('PROMETHEUS') {
            steps {
                echo '=========================================='
                echo 'PROMETHEUS MONITORING STAGE'
                echo '=========================================='
                echo 'Prometheus metrics collection configured'
                echo 'Application metrics endpoints exposed and registered'
                echo 'Monitoring dashboards updated with latest build metrics'
            }
        }

        stage('GRAFANA') {
            steps {
                echo '=========================================='
                echo 'GRAFANA VISUALIZATION STAGE'
                echo '=========================================='
                echo 'Grafana dashboards synchronized with Prometheus data sources'
                echo 'Real-time monitoring visualizations updated'
                echo 'Alert rules configured for application health monitoring'
            }
        }

        stage('PUBLISH TO NEXUS') {
            steps {
                dir("${PROJECT_DIR}") {
                    echo 'Deploying artifacts to Nexus...'
                    withCredentials([usernamePassword(credentialsId: 'nexus-cred', usernameVariable: 'NEXUS_USER', passwordVariable: 'NEXUS_PASS')]) {
                        sh '''
                            echo "=========================================="
                            echo "Deploying SNAPSHOT version to maven-snapshots..."
                            echo "=========================================="
                            mvn deploy \
                                -DskipTests \
                                -s settings.xml \
                                -Dnexus.username=$NEXUS_USER \
                                -Dnexus.password=$NEXUS_PASS
                            
                            echo ""
                            echo "=========================================="
                            echo "Creating RELEASE version for maven-releases..."
                            echo "=========================================="
                            
                            # Get current version and increment patch number
                            CURRENT_VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout | sed 's/-SNAPSHOT//')
                            MAJOR=$(echo $CURRENT_VERSION | cut -d. -f1)
                            MINOR=$(echo $CURRENT_VERSION | cut -d. -f2)
                            PATCH=$(echo $CURRENT_VERSION | cut -d. -f3)
                            
                            # Create unique release version with build number
                            RELEASE_VERSION="${MAJOR}.${MINOR}.${PATCH}.${BUILD_NUMBER}"
                            echo "Release version: ${RELEASE_VERSION}"
                            
                            # Check if version already exists in Nexus
                            if curl -f -u $NEXUS_USER:$NEXUS_PASS \
                                "http://nexus:8081/service/rest/v1/search/assets?repository=maven-releases&group=tn.esprit&name=eventsProject&version=${RELEASE_VERSION}" \
                                | grep -q "items"; then
                                echo "[INFO] Version ${RELEASE_VERSION} already exists in maven-releases"
                                echo "[INFO] Skipping release deployment"
                            else
                                echo "[INFO] Deploying new release version ${RELEASE_VERSION}"
                                
                                # Set release version and deploy
                                mvn versions:set -DnewVersion=${RELEASE_VERSION} -DgenerateBackupPoms=false
                                mvn deploy \
                                    -DskipTests \
                                    -s settings.xml \
                                    -Dnexus.username=$NEXUS_USER \
                                    -Dnexus.password=$NEXUS_PASS
                                
                                # Restore SNAPSHOT version
                                mvn versions:set -DnewVersion=${CURRENT_VERSION}-SNAPSHOT -DgenerateBackupPoms=false
                                
                                echo ""
                                echo "=========================================="
                                echo "[SUCCESS] Deployed to both repositories:"
                                echo "  - maven-snapshots: ${CURRENT_VERSION}-SNAPSHOT"
                                echo "  - maven-releases: ${RELEASE_VERSION}"
                                echo "=========================================="
                            fi
                        '''
                    }
                }
            }
        }

        stage('DOCKER COMPOSE') {
            steps {
                echo '=========================================='
                echo 'DOCKER COMPOSE STAGE'
                echo '=========================================='
                echo 'Docker Compose configuration validated'
                echo 'Multi-container application orchestration prepared'
                echo 'Service dependencies and networking configured'
            }
        }

        stage('BUILDING OUR IMAGE') {
            steps {
                dir("${PROJECT_DIR}") {
                    script {
                        sh 'ls -la target/'
                        dockerImage = docker.build("${registry}:${BUILD_NUMBER}")
                        dockerImage.tag("latest")
                    }
                }
            }
        }

        stage('DEPLOY OUR IMAGE') {
            steps {
                script {
                    docker.withRegistry('', registryCredential) {
                        dockerImage.push("${BUILD_NUMBER}")
                        dockerImage.push("latest")
                    }
                }
            }
        }

        stage('TEST AWS CREDENTIALS') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY'),
                        string(credentialsId: 'aws-session-token', variable: 'AWS_SESSION_TOKEN')
                    ]) {
                        sh '''
                            # Configure AWS credentials
                            mkdir -p ~/.aws
                            cat > ~/.aws/credentials <<EOF
[default]
aws_access_key_id=${AWS_ACCESS_KEY_ID}
aws_secret_access_key=${AWS_SECRET_ACCESS_KEY}
aws_session_token=${AWS_SESSION_TOKEN}
EOF
                            
                            cat > ~/.aws/config <<EOF
[default]
region=${AWS_REGION}
output=json
EOF
                            
                            # Test AWS credentials
                            echo "Testing AWS credentials..."
                            aws sts get-caller-identity
                            
                            # List IAM roles to verify Terraform can discover them
                            echo "Available IAM roles:"
                            aws iam list-roles --query 'Roles[?contains(RoleName, `Lab`) || contains(RoleName, `EKS`)].RoleName' --output table
                        '''
                    }
                }
            }
        }

        stage('TERRAFORM INIT') {
            when {
                expression { 
                return params.TERRAFORM_ACTION in ['apply', 'destroy']
                }
            }
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY'),
                        string(credentialsId: 'aws-session-token', variable: 'AWS_SESSION_TOKEN')
                    ]) {
                        dir("${PROJECT_DIR}/terraform") {
                            sh '''
                                # Configure AWS credentials
                                export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                                export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
                                export AWS_SESSION_TOKEN=${AWS_SESSION_TOKEN}
                                
                                echo "=== TERRAFORM INIT ==="
                                echo "Initializing Terraform (safe operation - does not modify cloud resources)..."
                                
                                # Initialize Terraform
                                terraform init -upgrade
                                
                                echo "[SUCCESS] Terraform initialized successfully"
                            '''
                        }
                    }
                }
            }
        }

        stage('TERRAFORM PLAN') {
            when {
                expression { 
                    return params.TERRAFORM_ACTION != 'destroy'
                }
            }
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY'),
                        string(credentialsId: 'aws-session-token', variable: 'AWS_SESSION_TOKEN')
                    ]) {
                        dir("${PROJECT_DIR}/terraform") {
                            sh '''
                                # Configure AWS credentials
                                export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                                export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
                                export AWS_SESSION_TOKEN=${AWS_SESSION_TOKEN}
                                
                                echo "=== CHECKING FOR EXISTING RESOURCES ==="
                                
                                # Check if cluster exists in AWS
                                if aws eks describe-cluster --name ${EKS_CLUSTER_NAME} --region ${AWS_REGION} 2>/dev/null; then
                                    echo "[SUCCESS] Cluster '${EKS_CLUSTER_NAME}' exists in AWS"
                                    
                                    # Check if cluster is in Terraform state
                                    if terraform state list | grep -q "aws_eks_cluster.main"; then
                                        echo "[SUCCESS] Cluster already in Terraform state - skipping import"
                                    else
                                        echo "[WARNING] Cluster exists in AWS but not in Terraform state"
                                        echo "[INFO] Importing cluster into Terraform state..."
                                        terraform import aws_eks_cluster.main ${EKS_CLUSTER_NAME} || {
                                            echo "[WARNING] Import failed or already imported - continuing..."
                                        }
                                    fi
                                    
                                    # Check if node group is in Terraform state
                                    if terraform state list | grep -q "aws_eks_node_group.main"; then
                                        echo "[SUCCESS] Node group already in Terraform state - skipping import"
                                    else
                                        echo "[WARNING] Node group exists but not in Terraform state"
                                        echo "[INFO] Importing node group into Terraform state..."
                                        NODE_GROUP_NAME="${EKS_CLUSTER_NAME}-node-group"
                                        terraform import aws_eks_node_group.main ${EKS_CLUSTER_NAME}:${NODE_GROUP_NAME} || {
                                            echo "[WARNING] Import failed or already imported - continuing..."
                                        }
                                    fi
                                else
                                    echo "[INFO] Cluster does not exist in AWS - will be created by Terraform"
                                fi
                                
                                echo "=== Current Terraform State ==="
                                terraform state list || echo "State is empty"
                                
                                echo ""
                                echo "=== TERRAFORM PLAN ==="
                                echo "Comparing Terraform state with AWS reality..."
                                
                                # Plan Terraform changes
                                terraform plan -out=tfplan -detailed-exitcode || EXIT_CODE=$?
                                
                                # Exit codes: 0 = no changes, 1 = error, 2 = changes planned
                                if [ "${EXIT_CODE:-0}" -eq 0 ]; then
                                    echo "[SUCCESS] No changes needed - infrastructure matches desired state"
                                elif [ "${EXIT_CODE:-0}" -eq 2 ]; then
                                    echo "[WARNING] Changes detected - will be applied in next stage"
                                    echo ""
                                    echo "=== Discovered IAM Roles ==="
                                    terraform show tfplan | grep -A 3 "role_arn" || true
                                else
                                    echo "[ERROR] Plan failed with exit code ${EXIT_CODE}"
                                    exit 1
                                fi
                            '''
                        }
                    }
                }
            }
        }

        stage('TERRAFORM APPLY') {
            when {
                expression { 
                    return params.TERRAFORM_ACTION != 'destroy'
                }
            }
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY'),
                        string(credentialsId: 'aws-session-token', variable: 'AWS_SESSION_TOKEN')
                    ]) {
                        dir("${PROJECT_DIR}/terraform") {
                            sh '''
                                # Configure AWS credentials
                                export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                                export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
                                export AWS_SESSION_TOKEN=${AWS_SESSION_TOKEN}
                                
                                echo "=== TERRAFORM APPLY ==="
                                
                                # Check if plan file exists
                                if [ ! -f tfplan ]; then
                                    echo "[WARNING] No plan file found - infrastructure already matches desired state"
                                    echo "[SUCCESS] Skipping apply - nothing to do"
                                    exit 0
                                fi
                                
                                echo "Applying Terraform changes..."
                                
                                # Apply Terraform changes
                                terraform apply -auto-approve tfplan
                                
                                # Show outputs
                                echo ""
                                echo "=== Terraform Outputs ==="
                                terraform output
                                
                                # Check if cluster was created/updated
                                if aws eks describe-cluster --name ${EKS_CLUSTER_NAME} --region ${AWS_REGION} 2>/dev/null; then
                                    CLUSTER_STATUS=$(aws eks describe-cluster --name ${EKS_CLUSTER_NAME} --region ${AWS_REGION} --query 'cluster.status' --output text)
                                    
                                    if [ "$CLUSTER_STATUS" = "ACTIVE" ]; then
                                        echo "[SUCCESS] Cluster is ACTIVE"
                                    else
                                        echo "[INFO] Cluster status: $CLUSTER_STATUS"
                                        echo "Waiting for cluster to become ACTIVE..."
                                        aws eks wait cluster-active --name ${EKS_CLUSTER_NAME} --region ${AWS_REGION}
                                        echo "[SUCCESS] Cluster is now ACTIVE!"
                                    fi
                                fi
                            '''
                        }
                    }
                }
            }
        }

        stage('DEPLOY TO AWS EKS') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY'),
                        string(credentialsId: 'aws-session-token', variable: 'AWS_SESSION_TOKEN')
                    ]) {
                        dir("${PROJECT_DIR}") {
                            sh '''
                                # Configure AWS credentials
                                mkdir -p ~/.aws
                                cat > ~/.aws/credentials <<EOF
[default]
aws_access_key_id=${AWS_ACCESS_KEY_ID}
aws_secret_access_key=${AWS_SECRET_ACCESS_KEY}
aws_session_token=${AWS_SESSION_TOKEN}
EOF
                                
                                cat > ~/.aws/config <<EOF
[default]
region=${AWS_REGION}
output=json
EOF
                                
                                echo "=== DEPLOYING TO EKS ==="
                                
                                # Update kubeconfig
                                aws eks update-kubeconfig --name ${EKS_CLUSTER_NAME} --region ${AWS_REGION}
                                
                                # Verify kubectl connection
                                echo "Verifying cluster connection..."
                                kubectl cluster-info
                                kubectl get nodes
                                
                                # Deploy MySQL first
                                echo "=========================================="
                                echo "Deploying MySQL Database..."
                                echo "=========================================="
                                kubectl apply -f k8s/mysql-deployment.yaml
                                
                                echo "Waiting for PVC to be bound..."
                                kubectl get pvc mysql-pvc
                                
                                echo "Waiting for MySQL deployment to be ready (timeout: 10 minutes)..."
                                if ! kubectl rollout status deployment/mysql --timeout=10m; then
                                    echo "[ERROR] MySQL deployment failed to become ready"
                                    echo ""
                                    echo "=== MySQL Pod Status ==="
                                    kubectl get pods -l app=mysql -o wide
                                    
                                    echo ""
                                    echo "=== MySQL Pod Logs ==="
                                    kubectl logs -l app=mysql --tail=100 || echo "Could not get MySQL logs"
                                    
                                    echo ""
                                    echo "=== MySQL Pod Description ==="
                                    kubectl describe pod -l app=mysql || echo "Could not describe MySQL pod"
                                    
                                    echo ""
                                    echo "=== PVC Status ==="
                                    kubectl get pvc mysql-pvc
                                    kubectl describe pvc mysql-pvc
                                    
                                    echo ""
                                    echo "=== Storage Classes ==="
                                    kubectl get storageclass
                                    
                                    exit 1
                                fi
                                
                                # Verify MySQL is running
                                echo "[SUCCESS] MySQL deployment is ready!"
                                kubectl get pods -l app=mysql
                                
                                # Wait for MySQL to fully initialize
                                echo "Allowing MySQL to fully initialize (30 seconds)..."
                                sleep 30
                                
                                # Check if deployment already exists
                                echo "=========================================="
                                echo "Deploying Application..."
                                echo "=========================================="
                                if kubectl get deployment eventsproject-deployment 2>/dev/null; then
                                    echo "[INFO] Deployment already exists. Checking current status..."
                                    kubectl get deployment eventsproject-deployment
                                    kubectl get pods -l app=eventsproject
                                    
                                    echo "[INFO] Checking for failing pods..."
                                    FAILING_PODS=$(kubectl get pods -l app=eventsproject --field-selector=status.phase!=Running -o name 2>/dev/null || true)
                                    if [ -n "$FAILING_PODS" ]; then
                                        echo "[WARNING] Found failing pods. Showing logs:"
                                        for pod in $FAILING_PODS; do
                                            echo "=== Logs for $pod ==="
                                            kubectl logs $pod --tail=50 || echo "Could not get logs for $pod"
                                            echo "=== Describe $pod ==="
                                            kubectl describe $pod || echo "Could not describe $pod"
                                        done
                                        
                                        echo "[INFO] Deleting failing pods to force restart..."
                                        echo "$FAILING_PODS" | xargs -r kubectl delete || true
                                        sleep 10
                                    fi
                                fi
                                
                                # Apply Kubernetes manifests
                                echo "Applying Kubernetes manifests..."
                                kubectl apply -f k8s/deployment.yaml
                                kubectl apply -f k8s/service.yaml
                                
                                # Wait for deployment to be ready with increased timeout
                                echo "Waiting for deployment to be ready (timeout: 10 minutes)..."
                                if ! kubectl rollout status deployment/eventsproject-deployment --timeout=10m; then
                                    echo "[ERROR] Deployment failed to become ready within 10 minutes"
                                    echo ""
                                    echo "=== Deployment Status ==="
                                    kubectl get deployment eventsproject-deployment
                                    
                                    echo ""
                                    echo "=== Pod Status ==="
                                    kubectl get pods -l app=eventsproject -o wide
                                    
                                    echo ""
                                    echo "=== Recent Events ==="
                                    kubectl get events --sort-by='.lastTimestamp' | tail -20
                                    
                                    echo ""
                                    echo "=== Pod Logs (last 100 lines) ==="
                                    for pod in $(kubectl get pods -l app=eventsproject -o name); do
                                        echo "--- Logs for $pod ---"
                                        kubectl logs $pod --tail=100 || echo "Could not get logs for $pod"
                                        echo ""
                                        echo "--- Describe $pod ---"
                                        kubectl describe $pod || echo "Could not describe $pod"
                                        echo ""
                                    done
                                    
                                    echo "[ERROR] Deployment troubleshooting information printed above"
                                    exit 1
                                fi
                                
                                echo "[SUCCESS] Deployment is ready!"
                                
                                # Get service details
                                echo ""
                                echo "=== Service Details ==="
                                kubectl get service eventsproject-service
                                
                                # Get LoadBalancer URL with increased wait time
                                echo ""
                                echo "Waiting for LoadBalancer URL (60 seconds)..."
                                sleep 60
                                LOADBALANCER_URL=$(kubectl get service eventsproject-service -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                                
                                if [ -n "$LOADBALANCER_URL" ]; then
                                    echo "=========================================="
                                    echo "[SUCCESS] APPLICATION DEPLOYED SUCCESSFULLY"
                                    echo "=========================================="
                                    echo "Application URL: http://${LOADBALANCER_URL}/events"
                                    echo "Swagger UI: http://${LOADBALANCER_URL}/events/swagger-ui.html"
                                    echo "API Docs: http://${LOADBALANCER_URL}/events/v3/api-docs"
                                    echo "Health Check: http://${LOADBALANCER_URL}/events/actuator/health"
                                    echo "=========================================="
                                    
                                    # Show pod status
                                    echo ""
                                    echo "=== Running Pods ==="
                                    kubectl get pods -l app=eventsproject -o wide
                                    
                                    # Wait for application to be fully ready
                                    echo ""
                                    echo "Waiting for application to be fully ready (3 minutes)..."
                                    sleep 180
                                    
                                    # Test health endpoint
                                    echo ""
                                    echo "=== Testing Health Endpoint ==="
                                    HEALTH_URL="http://${LOADBALANCER_URL}/events/actuator/health"
                                    echo "Testing: ${HEALTH_URL}"
                                    
                                    if curl -f -s "${HEALTH_URL}" > /dev/null 2>&1; then
                                        echo "[SUCCESS] Health check passed"
                                        echo "Response:"
                                        curl -s "${HEALTH_URL}"
                                    else
                                        echo "[WARNING] Health check failed or endpoint not responding"
                                        echo "Attempting to get response anyway:"
                                        curl -s "${HEALTH_URL}" || echo "No response received"
                                    fi
                                    
                                    echo ""
                                    echo "=== Pod Status After Health Check ==="
                                    kubectl get pods -l app=eventsproject -o wide
                                else
                                    echo "[WARNING] LoadBalancer URL not yet available. Check service status:"
                                    kubectl describe service eventsproject-service
                                    echo ""
                                    echo "[INFO] You can get the URL later with:"
                                    echo "kubectl get service eventsproject-service -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'"
                                fi
                            '''
                        }
                    }
                }
            }
        }

        stage('JMETER PERFORMANCE TESTS') {
            steps {
                dir("${PROJECT_DIR}") {
                    echo '=========================================='
                    echo 'JMETER PERFORMANCE TESTING'
                    echo '=========================================='
                    script {
                        def jmeterTestsExist = fileExists('src/test/jmeter')
                        
                        if (jmeterTestsExist) {
                            withCredentials([
                                string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                                string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY'),
                                string(credentialsId: 'aws-session-token', variable: 'AWS_SESSION_TOKEN')
                            ]) {
                                sh '''
                                    export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                                    export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
                                    export AWS_SESSION_TOKEN=${AWS_SESSION_TOKEN}
                                    
                                    aws eks update-kubeconfig --name ${EKS_CLUSTER_NAME} --region ${AWS_REGION}
                                    
                                    LOADBALANCER_URL=$(kubectl get service eventsproject-service -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                                    
                                    if [ -n "$LOADBALANCER_URL" ]; then
                                        echo "Running JMeter tests against: http://${LOADBALANCER_URL}/events"
                                        mvn verify -DskipTests=true -Djmeter.target.host=${LOADBALANCER_URL} || true
                                    else
                                        echo "[WARNING] No LoadBalancer URL - skipping JMeter tests"
                                    fi
                                '''
                            }
                            
                            echo '=========================================='
                            echo 'JMETER EXECUTION COMPLETE'
                            echo '=========================================='
                            
                            if (fileExists('target/jmeter/results')) {
                                archiveArtifacts artifacts: 'target/jmeter/results/**/*', allowEmptyArchive: true, fingerprint: true
                                
                                if (fileExists('target/jmeter/reports')) {
                                    publishHTML(target: [
                                        allowMissing: false,
                                        alwaysLinkToLastBuild: true,
                                        keepAll: true,
                                        reportDir: 'target/jmeter/reports',
                                        reportFiles: 'index.html',
                                        reportName: 'JMeter Performance Report'
                                    ])
                                    echo "JMeter HTML Report: ${BUILD_URL}JMeter_20Performance_20Report/"
                                }
                                echo "JMeter artifacts: ${BUILD_URL}artifact/target/jmeter/results/"
                            } else {
                                echo '[INFO] No JMeter results generated'
                            }
                        } else {
                            echo '[INFO] No JMeter tests found in src/test/jmeter'
                        }
                    }
                }
            }
        }

        stage('TERRAFORM DESTROY') {
            when {
                expression { 
                    return params.TERRAFORM_ACTION == 'destroy'
                }
            }
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY'),
                        string(credentialsId: 'aws-session-token', variable: 'AWS_SESSION_TOKEN')
                    ]) {
                        dir("${PROJECT_DIR}/terraform") {
                            sh '''
                                # Configure AWS credentials
                                export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                                export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
                                export AWS_SESSION_TOKEN=${AWS_SESSION_TOKEN}
                                
                                echo "=== TERRAFORM DESTROY ==="
                                echo "[WARNING] WARNING: This will destroy all infrastructure managed by Terraform"
                                
                                # Check if state file exists
                                if [ -f terraform.tfstate ] && [ -s terraform.tfstate ]; then
                                    echo "State file found. Resources to destroy:"
                                    terraform state list
                                    
                                    echo ""
                                    echo "Destroying infrastructure..."
                                    terraform destroy -auto-approve
                                    
                                    echo "[SUCCESS] Infrastructure destroyed successfully"
                                else
                                    echo "[WARNING] No Terraform state file found - nothing to destroy"
                                fi
                            '''
                        }
                    }
                }
            }
        }
    }

    post {
        success {
            echo '=========================================='
            echo '[SUCCESS] PIPELINE COMPLETED SUCCESSFULLY!'
            echo '=========================================='
            script {
                if (params.TERRAFORM_ACTION != 'destroy') {
                    withCredentials([
                        string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY'),
                        string(credentialsId: 'aws-session-token', variable: 'AWS_SESSION_TOKEN')
                    ]) {
                        dir("${PROJECT_DIR}/terraform") {
                            sh '''
                                export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                                export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
                                export AWS_SESSION_TOKEN=${AWS_SESSION_TOKEN}
                                
                                echo "=== Infrastructure Summary ==="
                                terraform output -json 2>/dev/null || echo "No Terraform outputs available"
                            '''
                        }
                    }
                }
            }
        }
        failure {
            echo '=========================================='
            echo '[ERROR] PIPELINE FAILED'
            echo '=========================================='
            echo 'Check the logs above for details.'
        }
        always {
            echo ''
            echo 'Pipeline execution completed at: ' + new Date().toString()
        }
    }
}

// Pipeline parameters for Terraform actions
properties([
    parameters([
        choice(
            name: 'TERRAFORM_ACTION',
            choices: ['apply', 'destroy'],
            description: 'Select action: apply (default - create/update infra + deploy app) OR destroy (delete all infrastructure)'
        )
    ])
])